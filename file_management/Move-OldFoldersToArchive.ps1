<#
.SYNOPSIS
    Archives top-level folders that haven't been modified since 2024 based on a CSV report.

.DESCRIPTION
    This script reads a CSV report generated by Get-TopLevelFolderReport.ps1, identifies folders
    with a NewestModifiedDate older than January 1, 2024, and moves them to an archive location.
    Includes WhatIf mode for safe testing and confirmation prompts before moving.

.NOTES
    File Name      : Move-OldFoldersToArchive.ps1
    Author         : Bryan Jackson
    Prerequisite   : PowerShell 5.1 or higher
    Version        : 1.0.0
    Date           : 2025-11-13

.PARAMETER WhatIf
    Shows what would be moved without actually moving anything.

.PARAMETER Force
    Skips the confirmation prompt before moving folders.

.EXAMPLE
    .\Move-OldFoldersToArchive.ps1
    Prompts for CSV file, shows what will be moved, asks for confirmation, then archives folders.

.EXAMPLE
    .\Move-OldFoldersToArchive.ps1 -WhatIf
    Shows what would be moved without actually moving anything.

.EXAMPLE
    .\Move-OldFoldersToArchive.ps1 -Force
    Moves folders without confirmation prompt (still shows preview).
#>

#Requires -Version 5.1

[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory=$false)]
    [switch]$WhatIf,
    
    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# Script configuration
$ArchivePath = "\\ecpsyn\Shares\Public\Archive"
$CutoffDate = Get-Date "2024-01-01"
$ScriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
$LogPath = Join-Path -Path $ScriptPath -ChildPath "ArchiveOperation_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

# Initialize logging function
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet('INFO','WARNING','ERROR','SUCCESS')]
        [string]$Level = 'INFO'
    )
    
    $Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $LogMessage = "$Timestamp [$Level] $Message"
    Add-Content -Path $LogPath -Value $LogMessage
    
    switch ($Level) {
        'INFO'    { Write-Host $LogMessage -ForegroundColor Cyan }
        'SUCCESS' { Write-Host $LogMessage -ForegroundColor Green }
        'WARNING' { Write-Host $LogMessage -ForegroundColor Yellow }
        'ERROR'   { Write-Host $LogMessage -ForegroundColor Red }
    }
}

# Function to select CSV file
function Select-CSVFile {
    Write-Host "`nPlease select the CSV report file to process..." -ForegroundColor Cyan
    
    Add-Type -AssemblyName System.Windows.Forms
    $OpenFileDialog = New-Object System.Windows.Forms.OpenFileDialog
    $OpenFileDialog.InitialDirectory = $ScriptPath
    $OpenFileDialog.Filter = "CSV files (*.csv)|*.csv|All files (*.*)|*.*"
    $OpenFileDialog.Title = "Select Top-Level Folder Report CSV"
    
    $Result = $OpenFileDialog.ShowDialog()
    
    if ($Result -eq 'OK') {
        return $OpenFileDialog.FileName
    }
    else {
        return $null
    }
}

# Function to move folder with error handling
function Move-FolderToArchive {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SourcePath,
        
        [Parameter(Mandatory=$true)]
        [string]$DestinationPath,
        
        [Parameter(Mandatory=$true)]
        [string]$FolderName,
        
        [Parameter(Mandatory=$false)]
        [switch]$WhatIfMode
    )
    
    try {
        $DestinationFullPath = Join-Path -Path $DestinationPath -ChildPath $FolderName
        
        if ($WhatIfMode) {
            Write-Log -Message "  [WHATIF] Would move: $SourcePath -> $DestinationFullPath" -Level 'INFO'
            return $true
        }
        
        # Check if destination already exists
        if (Test-Path -Path $DestinationFullPath) {
            Write-Log -Message "  WARNING: Destination already exists: $DestinationFullPath" -Level 'WARNING'
            Write-Log -Message "  Skipping to prevent overwrite..." -Level 'WARNING'
            return $false
        }
        
        # Perform the move
        Move-Item -Path $SourcePath -Destination $DestinationFullPath -Force -ErrorAction Stop
        Write-Log -Message "  Successfully moved: $FolderName" -Level 'SUCCESS'
        return $true
    }
    catch {
        Write-Log -Message "  ERROR moving $FolderName : $($_.Exception.Message)" -Level 'ERROR'
        return $false
    }
}

# Main script execution
try {
    Write-Log -Message "========================================" -Level 'INFO'
    Write-Log -Message "Starting Archive Operation Script" -Level 'INFO'
    Write-Log -Message "Archive Location: $ArchivePath" -Level 'INFO'
    Write-Log -Message "Cutoff Date: $($CutoffDate.ToString('yyyy-MM-dd'))" -Level 'INFO'
    Write-Log -Message "WhatIf Mode: $($WhatIf.IsPresent)" -Level 'INFO'
    Write-Log -Message "========================================" -Level 'INFO'
    
    # Select CSV file
    $CSVPath = Select-CSVFile
    
    if (-not $CSVPath) {
        Write-Log -Message "No CSV file selected. Exiting script." -Level 'WARNING'
        return
    }
    
    Write-Log -Message "Selected CSV: $CSVPath" -Level 'INFO'
    
    # Verify CSV file exists
    if (-not (Test-Path -Path $CSVPath)) {
        throw "CSV file not found: $CSVPath"
    }
    
    # Import CSV data
    Write-Log -Message "Importing CSV data..." -Level 'INFO'
    $ReportData = Import-Csv -Path $CSVPath
    
    if ($ReportData.Count -eq 0) {
        Write-Log -Message "No data found in CSV file." -Level 'WARNING'
        return
    }
    
    Write-Log -Message "Found $($ReportData.Count) folders in report" -Level 'INFO'
    
    # Filter folders older than cutoff date
    Write-Log -Message "Filtering folders older than $($CutoffDate.ToString('yyyy-MM-dd'))..." -Level 'INFO'
    
    $FoldersToArchive = $ReportData | Where-Object {
        try {
            $ModDate = [DateTime]::Parse($_.NewestModifiedDate)
            $ModDate -lt $CutoffDate
        }
        catch {
            # If date parsing fails, log and skip
            Write-Log -Message "Unable to parse date for folder: $($_.FolderName) (Date: $($_.NewestModifiedDate))" -Level 'WARNING'
            $false
        }
    }
    
    if ($FoldersToArchive.Count -eq 0) {
        Write-Log -Message "No folders found that meet the archive criteria." -Level 'INFO'
        Write-Log -Message "All folders have been modified since $($CutoffDate.ToString('yyyy-MM-dd'))" -Level 'INFO'
        return
    }
    
    Write-Log -Message "Found $($FoldersToArchive.Count) folders to archive" -Level 'INFO'
    Write-Log -Message "" -Level 'INFO'
    
    # Display folders that will be archived
    Write-Host "`n========================================" -ForegroundColor Yellow
    Write-Host "FOLDERS TO BE ARCHIVED:" -ForegroundColor Yellow
    Write-Host "========================================" -ForegroundColor Yellow
    
    foreach ($Folder in $FoldersToArchive) {
        $ModDate = [DateTime]::Parse($Folder.NewestModifiedDate)
        Write-Host "  - $($Folder.FolderName) (Last Modified: $($ModDate.ToString('yyyy-MM-dd')))" -ForegroundColor White
        Write-Log -Message "  Will archive: $($Folder.FolderName) (Last Modified: $($ModDate.ToString('yyyy-MM-dd')))" -Level 'INFO'
    }
    
    Write-Host "========================================`n" -ForegroundColor Yellow
    
    # WhatIf mode - exit after showing what would happen
    if ($WhatIf) {
        Write-Log -Message "WhatIf mode enabled - no folders will be moved" -Level 'INFO'
        Write-Log -Message "Re-run without -WhatIf to perform the actual move" -Level 'INFO'
        
        # Show what would happen for each folder
        foreach ($Folder in $FoldersToArchive) {
            $DestPath = Join-Path -Path $ArchivePath -ChildPath $Folder.FolderName
            Write-Log -Message "  [WHATIF] $($Folder.FolderPath) -> $DestPath" -Level 'INFO'
        }
        
        return
    }
    
    # Confirmation prompt (unless Force is specified)
    if (-not $Force) {
        Write-Host "Do you want to proceed with archiving these $($FoldersToArchive.Count) folders? (Y/N): " -ForegroundColor Cyan -NoNewline
        $Response = Read-Host
        
        if ($Response -ne 'Y' -and $Response -ne 'y') {
            Write-Log -Message "Operation cancelled by user" -Level 'WARNING'
            return
        }
    }
    
    Write-Log -Message "" -Level 'INFO'
    Write-Log -Message "Beginning archive operation..." -Level 'INFO'
    
    # Create archive folder if it doesn't exist
    if (-not (Test-Path -Path $ArchivePath)) {
        Write-Log -Message "Archive folder does not exist. Creating: $ArchivePath" -Level 'INFO'
        try {
            New-Item -Path $ArchivePath -ItemType Directory -Force -ErrorAction Stop | Out-Null
            Write-Log -Message "Archive folder created successfully" -Level 'SUCCESS'
        }
        catch {
            throw "Failed to create archive folder: $($_.Exception.Message)"
        }
    }
    else {
        Write-Log -Message "Archive folder exists: $ArchivePath" -Level 'INFO'
    }
    
    # Archive each folder
    $SuccessCount = 0
    $FailureCount = 0
    $SkipCount = 0
    $CurrentFolder = 0
    
    foreach ($Folder in $FoldersToArchive) {
        $CurrentFolder++
        $PercentComplete = [math]::Round(($CurrentFolder / $FoldersToArchive.Count) * 100, 2)
        
        Write-Progress -Activity "Archiving Folders" `
                       -Status "Processing: $($Folder.FolderName) ($CurrentFolder of $($FoldersToArchive.Count))" `
                       -PercentComplete $PercentComplete
        
        Write-Log -Message "[$CurrentFolder/$($FoldersToArchive.Count)] Archiving: $($Folder.FolderName)" -Level 'INFO'
        
        # Verify source folder still exists
        if (-not (Test-Path -Path $Folder.FolderPath)) {
            Write-Log -Message "  Source folder no longer exists: $($Folder.FolderPath)" -Level 'WARNING'
            $SkipCount++
            continue
        }
        
        # Move the folder
        $MoveResult = Move-FolderToArchive -SourcePath $Folder.FolderPath `
                                           -DestinationPath $ArchivePath `
                                           -FolderName $Folder.FolderName
        
        if ($MoveResult) {
            $SuccessCount++
        }
        else {
            $FailureCount++
        }
    }
    
    Write-Progress -Activity "Archiving Folders" -Completed
    
    # Final summary
    Write-Log -Message "" -Level 'INFO'
    Write-Log -Message "========================================" -Level 'INFO'
    Write-Log -Message "Archive Operation Complete!" -Level 'SUCCESS'
    Write-Log -Message "Total folders processed: $($FoldersToArchive.Count)" -Level 'INFO'
    Write-Log -Message "Successfully archived: $SuccessCount" -Level 'SUCCESS'
    Write-Log -Message "Failed to archive: $FailureCount" -Level $(if ($FailureCount -gt 0) { 'WARNING' } else { 'INFO' })
    Write-Log -Message "Skipped (not found): $SkipCount" -Level $(if ($SkipCount -gt 0) { 'WARNING' } else { 'INFO' })
    Write-Log -Message "Archive location: $ArchivePath" -Level 'INFO'
    Write-Log -Message "Log file: $LogPath" -Level 'INFO'
    Write-Log -Message "========================================" -Level 'INFO'
    
    # Offer to open archive location
    if ($SuccessCount -gt 0) {
        Write-Host "`nWould you like to open the archive location? (Y/N): " -ForegroundColor Cyan -NoNewline
        $Response = Read-Host
        if ($Response -eq 'Y' -or $Response -eq 'y') {
            Start-Process explorer.exe -ArgumentList $ArchivePath
        }
    }
}
catch {
    Write-Log -Message "FATAL ERROR: $($_.Exception.Message)" -Level 'ERROR'
    Write-Log -Message "Stack Trace: $($_.ScriptStackTrace)" -Level 'ERROR'
    throw
}
finally {
    Write-Log -Message "Script execution ended" -Level 'INFO'
}
